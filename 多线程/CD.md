###  实现原理

**await内部实现流程:**

1. 判断state计数是否为0，不是，则直接放过执行后面的代码
2. 大于0，则表示需要阻塞等待计数为0
3. 当前线程封装Node对象，进入阻塞队列
4. 然后就是循环尝试获取锁，直到成功（即state为0）后出队，继续执行线程后续代码

**countDown内部实现流程:**

1. 尝试释放锁`tryReleaseShared`，实现计数-1

- 若计数已经小于0，则直接返回false
- 否则执行计数(AQS的state)减一
- 若减完之后，state==0，表示没有线程占用锁，即释放成功，然后就需要唤醒被阻塞的线程了

2. 如果也是共享类型，释放并唤醒阻塞线程 `doReleaseShared`

- 如果队列为空，即表示没有线程被阻塞（也就是说没有线程调用了 CountDownLatch#wait()方法），直接退出
- 头结点如果为SIGNAL, 则依次唤醒头结点下个节点上关联的线程，并出队

​        下个节点被唤醒后，重复上面的步骤，达到共享状态向后传播。

​	要注意，await操作看着好像是独占操作，但它可以在多个线程中调用。当计数值等于0的时候，调用await的线程都需要知道，所以使用共享锁。





