### 虚拟内存

如果存在一个程序，**所需内存空间超过了计算机可以提供的实际内存**，那么由于该程序无法装入内存所以也就无法运行。单纯的增加物理内存只能解决一部分问题，但是仍然会出现无法装入单个或者无法同时装入多个程序的问题。但是可以**从逻辑的角度扩充内存容量**

- 在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存（DISK），

- 当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。

- 暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。

  （系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。）

### 基本分页储存管理方式

因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，**因此需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射。**

**两次的内存访问**(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址(Offset)；第二次就是根据第一次得到的物理地址访问内存取出数据)。

为了减少两次访问内存导致的效率影响，分页管理中引入了**快表机制**

![Image result for tlb cache](https://upload.wikimedia.org/wikipedia/commons/thumb/6/6e/Translation_Lookaside_Buffer.png/373px-Translation_Lookaside_Buffer.png)

**TLB**

TLB中存放了部分PTE页表的缓存。而CPU寻址时会优先在TLB中进行寻址。TLB是在MMU中包括的一段小的缓存(MMU memory management unit 存储器管理单元，是CPU芯片上的一个专用硬件)。处理器的性能就和寻址的命中率有很大的关系。

1. 如果TLB中正好存放着所需的页表，则称为TLB命中(TLB Hit)；如果TLB中没有所需的页表，则称为TLB失败(TLB Miss)。

1. 如果命中的话，就可以直接将虚拟地址转换为物理地址，如果不命中，则必须在PTE页表中继续查找，并将找到的PTE存放到TLB中，覆盖已经存在的一个条目。

1. TLB中的表项在某些情况下是无效的，比如进程切换，更改内核页表等，此时CPU硬件不知道哪些TLB表项是无效的，只能由软件在这些场景下，刷新TLB。

### 内存连续分配

动态分区分配：不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。

**Best Fit**：分配器将进程放在最适合的未分配内存块中。例如，假设一个进程请求12KB的内存，并且内存管理器当前有一个包含6KB，14KB，19KB，11KB和13KB块的未分配块的列表。最合适的策略将为流程分配12KB的13KB块。

**Worst** **Fit**：内存管理器将进程放在可用的最大未分配内存块中。我们的想法是，此分配将在分配后创建最大的保留，从而增加了与最佳匹配相比，另一个过程可以使用剩余空间的可能性。使用与上面相同的示例，最差拟合将为该过程分配12KB的19KB块，留下7KB块以供将来使用。

**First** **Fit**：内存中可能有很多漏洞，因此操作系统减少分析可用空间所花费的时间，从主存储器的开始处开始，并从它遇到的第一个孔中分配内存以满足要求请求。使用与上面相同的示例，first fit将为进程分配12KB的14KB块。



## 进程调度算法

**先来先服务调度算法FCFS：**既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利；

**短作业优先调度算法SJF：**作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；

**高相应比算法HRN：**响应比=(等待时间+要求服务时间)/要求服务时间；

**时间片轮转调度RR：**按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;

**多级反馈队列调度算法：**目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。

### 页面置换算法

**最佳置换算法：**只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。

**先进先出置换算法：**简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。

**最近最久未使用算法LRU：**算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。

**时钟算法clock(也被称为是最近未使用算法NRU)：**页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。

**改进型Clock算法：**在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。

**最少使用算法LFU：**设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。

