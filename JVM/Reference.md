# **Java的引用**

Java的引用机制有四种，**强引用**，**弱引用**，**软引用**和**虚引用**。 


### **强引用**： 

垃圾回收器绝不会回收它，当内存空间不足，Java虚拟机宁愿抛出**OutOfMemoryError**错误，使程序异常终止

显式地设置o为**null**，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法

### **软引用**： 

内存空间不足够 OOM，垃圾回收器就会回收它

可用来实现**内存敏感**的**高速缓存**

当内存不足时，等价于：   

```java
If(JVM.内存不足()) {
   str = null;  // 转换为软引用
   System.gc(); // 垃圾回收器进行回收
}
```

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。

### **弱引用**： 

对象拥有**更短暂的生命周期**。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，**不管当前内存空间足够与否，都会回收它的内存**。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。

 当垃圾回收器进行扫描回收时等价于：   

```java
str = null;
System.gc();
```

#### 作用：

 如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。

当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。  

### **虚引用**

虚引用并**不会决定对象的生命周期**。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

**当试图通过虚引用的get()方法取得强引用时，总是会返回null**

虚引用主要**用来跟踪对象被垃圾回收器回收的活动**。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。**当垃圾回收器准备回收一个对象时，如果发现它还有虚引用**，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。(Inform Object no longer reachable)

#### 作用：

使用虚引用的目的就是为了得知对象被GC的时机，所以可以利用虚引用来进行销毁時（不確定顺序）的一些操作，比如说资源释放等

### finalize()方法最终判定对象是否存活

当对象变成(GC Roots)不可达时，它并不一定非死不可。要真正宣告一个对象死亡，至少要经历两次标记过程。

标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。
1. #### 第一次标记并进行一次筛选

  如果对象不可达，那么它将会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行finalize()方法。
  当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。

2. #### 第二次标记

    如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为：F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。
       Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize（）中成功拯救自己----只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。

### finalize Con:

**调用时间不确定——有资源浪费的风险**

如果把某些稀缺资源放到finalize()中释放，可能会导致该稀缺资源等上很久很久以后才被释放。造成资源的浪费！另外，某些类对象所携带的资源（比如某些JDBC的类）可能本身就很耗费内存，这些资源的延迟释放会造成很大的性能问题。

**可能不被调用——有资源泄漏的风险**

在某些情况下，finalize()压根儿不被调用。比如在JVM退出的当口，内存中那些对象的finalize函数可能就不会被调用了。

因此一些清理工作如文件的关闭，连接的关闭等不要放到finalize函数中，要在程序中单独进行管理，一般finalize只做C/C++内存的回收。

### 结论

对象的`finalize()`方法被执行，弱引用进入队列。这两个动作不确定顺序。

很多时候，我们认为一个对象的`finalize()`方法执行过以后，如果对象没有自救，这个对象马上就被垃圾回收了。但是实际不然，有个时间差，要到下次垃圾回收时才会真正回收掉这个对象。



### 弱引用和虚引用的区别？

只要jvm有回收掉一个对象的意愿，不管最终有没有回收掉，都会在回收对象之前将弱引用加入到引用队列。 
而只有在jvm真正回收掉对象之后，才会把虚引用加入引用队列

https://blog.csdn.net/yizishou/article/details/71194944

![image-20190221185952252](/Users/ck/Library/Application Support/typora-user-images/image-20190221185952252.png)